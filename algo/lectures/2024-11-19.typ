#import "/utils/math.typ": *

= Остовы

Есть *связный, неориентированный, взвешенный* граф: $G = (V, E), w: E -> RR$

Пусть:
- $n = |V|$
- $m = |E|$

Варианты хранения:
-
    - `vector<vector<int>> g` --- список смежности
    - `vector<vector<int>> w` --- список весов
- `vector<vector<pair<int, int>>> g` --- вектор пар `(w, v)`
- `vector<tuple<int, int, int>> g` --- список ребер `(w, u, v)`

#def[
    #defitem[Остовное дерево] графа $G$ --- поддерево данного графа, содержащее
    все вершины: $G' = (V, E'), E' subset E$
]

#def[
    #defitem[Минимальный остов (MST)] взвешенного графа $G$ --- остов $G$ с
    минимальный суммарным весом ребер
]

#def[
    #defitem[Безопасный подграф] $G_b$ графа $G$, если
    $exists "MST" G' "графа" G: G_b subset G'$

    Т.е. $G_b$ можно дополнить до какого-то MST.

    "Промежуточный шаг на пути к МСТ"
]

#def[
    Безопасное #defitem[ребро] $e$ для безопасного подграфа $G_b$, если
    $G_b union e$ --- безопасный граф

    "Если к безопасному подграфу добавить безопасное ребро, то граф останется
    безопасный"
]

#def[
    #defitem[Разрез] $V = V_1 union.sq V_2$ --- разбиение графа на два
    *не пересекающихся*

    Другое обозначение: $<V_1, V_2>$--разрез
]

#def[
    Ребро $e = (a, b)$ #defitem[пересекает разрез] $<V_1, V_2>$--разрез, если
    $a in V_1$ и $b in V_2$ (или наоборот)
]

#def[
    Разрез #defitem[совместим] с безопасным графом $G_b = (V, E_b)$, если ребра
    из $G_b$ не пересекают разрез.
]

#def[
    #defitem[$E_"cross"$] --- все ребра, которые пересекают $<V_1, V_2>$--разрез
]

== Лемма о безопасном ребре

$e$ --- одно из ребер минимального веса в $E_"cross"$, то $e$ --- безопасное
ребро

=== Доказательство

*\* Тут должно быть доказательство \**

== Алгоритм Краскала (1956)

- Сортируем ребра по весу $O(m log n) = O(m log m)$
- Идем в порядке сортировки. Берем очередное ребро в остов, если оно соединяет
  разные компоненты связности (для этого используем DSU)

Итого,
- $O(m log n + m + alpha(n) n) = O(m log n)$, если нужно сортировать
- $O(m + alpha(n) n)$, если уже отсортировано

== Алгоритм Борувки (1926)

Старт: $n$ множеств

Стадия: для каждого множества смотрим на минимальное ребро, из него торчащее, и
добавляем его, если оно соединяет разные компоненты

$O(m log n)$

Может найти полостова за линию
