= Графы

Граф $G = (V, E)$ --- множество вершин $V$ и ребер $E$

== Виды графов

- *Ориентированный (орграф)*: каждое ребро направлено в одну из сторон
- *Не ориентированный*

#line(length: 100%)

- *Взвешенный*: к каждому ребру дописано некоторое число -- его вес
- *Не взвешенный*

#line(length: 100%)

Граф может иметь:
- *Петли*: ребро из вершины в саму себя
- *Кратные ребра*: несколько ребер между одной парой вершин

== Как хранить граф?

=== Матрица смежности

Храним матрицу `g[n][n]`

`g[i][j]` --- вес ребра $(i, j)$ (или 0/1 для неориентированного)

Требует очень много ($O(n^2)$) памяти

=== Список смежности

Храним `vector<vector<int>> g`

`g[i]` --- список всех ребер из вершины `i`

Требует $O(m)$ памяти, где $m = abs(E)$

*Самый базовый вариант*

=== Множество смежности

Аналогично списку смежности, но `vector<set<int>> g`

=== Список ребер

Храним `vector<pair<int, int>> edges` --- список ребер

== Определения

Для неориентированного:
- *Компонента связности* --- подмножество вершин, где из каждой можно попасть в
  каждую
- *Двудольный граф* --- можно раскрасить вершины в два цвета, что ребра соединают
  разные цвета
- *Остов* --- подграф, содержащий все вершины и являющийся деревом

Для ориентированного:
- *Компоненты сильной связности (КСС)* --- подмножество вершин, где из каждой можно попасть в
  каждую
- *DAG (Directed Acyclic Graph)* --- ориентированный граф без циклов
- *TopSort* --- нумерация вершин таким образом, что ребро всегда ведет из вершины
  с меньшим номером в вершину с большим

Для взвешенного:
- *Минимальный остов* --- остов минимального веса

Для всех:
- *Кратчайшее расстояние между двумя вершинами*

= BFS (breadth first search)

Хотим найти кратчайшие расстояние от вершины $Q$ до всех остальных

Аналогия с пожаром

```
dist[Q] = 0
dist[соседи Q] = 1
dist[ещё не рассмотренные соседи соседей Q] = 2
...
```

Используем `queue`

= 0-1 BFS

Модификация BFS для графов, где ребра имеют вес либо 1, либо 0

Используем не `queue`, а `deque`

= DFS

Пишется приятнее, чем BFS

Заводим массив `used[n]`: `used[i]` --- были ли мы в вершине `i`

Во время работы алгоритма ребра делятся на несколько типов:
- Для орграфа:
    - *Ребро обхода* --- ребро, по которому мы прошли
    - *Прямое ребро* --- ребро, ведущее в потомка, по которому мы не ходили
    - *Обратное ребро* --- ребро, ведущее в предка
    - *Перекрестное ребро* --- ребро, ведущее ни в предка, ни в потомка
- Для неорграфа:
    - Нет перекрестных ребер
    - Обратные и прямые ребра не отличимы

Код:
```cpp
void dfs(int v) {
    used[v] = 1;
    for (int to : g[v]) {
        if (!used[v]) {
            dfs(v);
        }
    }
}
```

Альтернативный код:
```cpp
void dfs(int v) {
    if (used[v]) return;
    used[v] = 1;

    for (int to : g[v]) {
        dfs(v);
    }
}
```

Применения:
- Количество компонент связности
- Поиск остовного дерева (леса)
- Проверка двудольности
- Поиска цикла
- Поиск эйлерого пути
- Много всего ещё ...

При обходе дерева можно не хранить `used`, а просто передавать предка:
`void dfs(int v, int p)`

Через dfs можно считать динамику:
- ДП снизу: `sz[v]`
- ДП сверху: `dep[v]`
