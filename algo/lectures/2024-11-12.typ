= Приливания

Делаем динамику на дереве

В поддеревьях хотим считать какую-то штуку, размер которой имеет размер порядка
размера поддерева. На первый взгляд, для несбалансированного дерева это долгая
операция.

== На примере

Пусть есть некоторые "выделенные" вершины. Их примерно $O(n)$.

Для каждой вершины в какой-то момент времени хотим иметь множество всех
выделенных вершин в её поддереве: $S(v)$.

Пусть у $v$ есть дочерние вершины $v_1, ...,  v_n$. $S(v_1), ..., S(v_n)$ уже
посчитали. Хотим $S(v)$.

Пусть $"sz"(v_1) >= "sz"(v_2) >= ... >= "sz"(v_n)$. В $"sz"(v_1)$ добавляем
("приливаем") остальные множества. В конце получим $"sz"(v)$.

В итоге будет $O(n log n)$ *добавлений*.

== Доказательство времени работы

Рассмотрим конкретную вершину $x$.

$x$ в начале попадет в какое-то множество с размером $1$. $x$ будет перемещаться
только в множество, с бОльшим размером. Итого, размер множества, где лежит $x$
увеличивается хотя бы в два раза. Значит, каждый элемент "приливается" не более
$log n$ раз. Всего не более $O(n log n)$ приливаний.

= Система непересекающихся множеств\ (Disjoint Set Union)

- Изначально есть $n$ множеств по одному элементу.
- Делаем $m$ запросов следующих видов:
    - Можно объединить два множества (множество идентифицируется по любому его
      элементу)
    - Узнать "цвет" (идентификатор) множества
    - Проверить, в одном ли множестве лежат две вершины
    - Узнать размер (или другую характеристику) множества

Пусть элементы пронумерованы $0, ..., n - 1$

== Первая версия

Заведем массив цветов `col[n]` и размеров `size[color]`.

Изначально: `col[i] = i`

`unite` работает за $O(n)$ (просто перекрашиваем одно множество в другое),
остальное --- за $O(1)$

Итого, $O(n^2 + m)$ т.к. максимум $n$ объединений

== Вторая версия (с приливаниями)

Для каждого цвета храним позиции элементов этого цвета в
списке#footnote[используем именно список, чтобы можно было быстро их объединять]
`ind[color]`.

Для `unite` перекрашиваем элементы *меньшего* множества в цвет *большего*. Для
этого обновляем массивы `col` и `ind`.

Так как приливания, то $O(n log n + m)$.

== Третья версия

"Ранговая эвристика"

Каждое множество --- это дерево

Для хранения дерева просто храним предка каждой вершины (список дочерних
элементов не храним) -- массив `p[v]`. Пусть в для корня: `p[root] = root`

Изначально: `p[i] = i`

Цвет --- номер корня дерева

```python
def unite(a, b):
    a = col(a) # Перешли от самих вершин, к их корням
    b = col(b)

    if a == b:
        return

    # Подвешиваем меньшее к большему
    if sz(a) < sz(b):
        swap(a, b)

    p[a] = b
    sz[a] += sz[b]
```

В качестве "размера" дерева можно брать либо размер поддерева, либо высоту, но
лучше брать размер поддерева.

Получаем $O(n log n + m underbrace(log n, "т.к. col за" log n))$

== Четвертая версия (со сжатием путей)

"Эвристика сжатия путей"

Улучшение четвертой версии

`unite` такой же

```python
def col(a):
    # Если a --- корень дерева, то вернем его
    if p[a] == a:
        return a

    # Переподвесим вершину к корню. Так мы уменьшим глубину дерева.
    p[a] = col(p[a])

    return p[a]
```

Получаем $O(n dot alpha(n) + m)$

$alpha(n)$ --- обратная функция Аккермана. При всех нормальных значениях
$alpha(n) < 4$

Есть гипотеза, что сложность будет $O(n + m)$, но это доказано.

== СНМ с откатами

Откаты (rollbacks) --- самая слабая версия персистентности. Можем откатиться на шаг назад.

Нужно делать без сжатия путей

Храним "лог изменений": массив вершин, которую мы подвешивали в очередном `unite`
