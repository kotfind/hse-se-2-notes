#import "/utils/math.typ": *

= Введение

Оценка:
- 2 контрольных на лекциях (40 баллов)
- Письменный экзамен (60 баллов)
- Задачи в ejudge (ДЗ) (10, 10, 5, 10 баллов)
    - Бывают частичные баллы
- Контест на Regexp (5 баллов)
    - Бывают частичные баллы

Сайт курса: #link("https://earth.ispras.ru")

= Основные определения

#def[
    #defitem[Алфавит ($V$)] --- конечное непустое множество символов.

    Символы --- некоторые произвольные объекты.
]

#def[
    #defitem[Слово (строка, предложение)] --- любая цепочка конечной длины,
    из символов алфавита.
]

#def[
    #defitem[$epsilon$] --- пустое слово
]

#def[
    #defitem[$V^*$] --- множество всех слов из символов $V$.
]

#def[
    #defitem[$V^+$] = $V* \\ {epsilon}$
]

#def[
    #defitem[$|x|$] --- длина строки
]

#def[
    #defitem[$x y$] --- конкатенация
]

#def[
    #defitem[Язык $L$] --- подмножество слов: $L subset V^*$
]

#def[
    #defitem[$overline(L)$] = $V^* \ L$
]

= Как задать язык?

Языков континуум, а нотаций --- конечно. Поэтому не все языки можно задать.

Способы задания:
- Распознавание
    Процедура, которая для конкретного слова говорит, принадлежит ли оно языку.
    Если процедура не завершилась, то слово языку не принадлежит
- Порождение
    Процедура, которая последовательно выдает слова

Процедура vs Алгоритм (в контексте курса):
- Процедура --- просто последовательность инструкция
- Алгоритм --- процедура, которая завершается за конечное время

Типы языков:
- Рекурсивно перечислимые --- существует *процедура* распознавания
- Рекурсивный --- существует *алгоритм* распознавания
- Не перечислимые

#blk(title: [Теорема])[intersect
    Если $L$ и $overline(L)$ рекурсивно перечислимы, то $L$ рекурсивен.
]

= Грамматики
Способ порождения языков

#def[
    #defitem[Грамматика]: $G = (V_N, V_T, P, S)$, где
    - $V_N$ --- алфавит нетерминальных символов,
    - $V_T$ --- алфавит терминальных символов, причем $V_N in V_T =
      emptyset, V_N union V_T = V$
    - $P$ --- конечное множество правил вида $alpha -> beta, alpha in V^* V_N
      V^*, beta in V^*$,
    - $S$ --- стартовый символ (начальный нетерминал, аксиома грамматики).
]

#def[
    #defitem[Язык порождаемый грамматикой $G$] --- множество всех терминальных
    строк, выводимых из начального символа.

    $ L(G) = { omega | omega in V_T^*, S =>_G^* omega } $
]

#def[
    #defitem[Сентенциальная форма] --- любая "промежуточная" строка:

    $ alpha in V^* and S =>_G^* alpha $
]

#def[
    Грамматики #defitem[эквивалентны], если $L(G_1) = L(G_2)$
]

#blk(title: [Пример грамматики])[
    ```
    G = (
        {S},
        {0, 1},
        {S -> 0S1, S -> 01},
        S
    )
    ```

    ```
    S => 0S1 => 00S11 => ... => 0...0S1...1
    ```

    $ L(G) = {0^n_1^n | n > 0} $
]

