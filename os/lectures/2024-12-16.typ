= Сети и сетевые ОС

== Одноуровневая адресация

- Пользователь запрашивает свою ОС о возможности использовать адрес
- ОС спрашивает все другие ОС о возможности присвоения адреса
- После сбора всех ответов ОС принимает решение
- ОС извещает процесс о принятом решении

Используется в небольших сетях, ибо в больших очень сильно тормозит.

== Двухуровневая адресация

Каждый узел получает имя (удаленный адрес). Внутри узла каждый процесс тоже
получает имя (локальный адрес). Полный адрес = удаленный адрес + локальный
адрес.

Возникают проблемы:
- уникальности адресов
- разрешения адресов: человеку понятнее символьные адреса, машине --- цифровые

Есть несколько крайних подходов. На самом деле используется что-то среднее.

=== Централизованный подход

Есть выделенный сервер, на котором в специальном файле хранится соответствие
между символьными и числовыми адресами

Файл с изменениями время от времени рассылается всем

Используется в малых сетях

=== Распределенный подход

На примере DNS

Используем идею, как я файловой системе: построим иерархию 

Всё разбивается на ранги: от 0 до 3-4

В каждом ранге назначаем "главного" -- сервер

Каждому серверу назначается некоторое множество числовых адресов, которые он
распределяет

В каждом ранге есть сервер DNS

Это решает обе проблемы для удаленных адресов

=== Как строить локальные адреса?

PID не подходит в качестве локального адреса, так как соответствует процессу, а
не приложению

Создается отдельное пространство *сетевых портов*

За приложением закрепляется некоторый порт

Для разных протоколов разное сетевое пространство

Полный адрес получил название socket

== Маршрутизация

Как выбирается маршрут от отправителя до получателя

=== Маршрутизация от источника передачи данных

В пакет вписывается весь путь -- полная последовательность узлов

Требует знания топологии сети от программиста

Пересылка очень быстрая

=== Одношаговая маршрутизация

Пакет знает только адреса отправителя и получателя

Программист не думает о топологии сети

Даже при изменении топологии сети всё работает

Требует особые алгоритмы маршрутизации

Виды алгоритмов маршрутизации:
- Фиксированной маршрутизации

    В каждом узле есть таблица маршрутов

    Быстро работает

    Нужно настраивать вручную

- Простая маршрутизация

    - Лавинная

        Полученный пакет рассылается по всем линиям связи, кроме той, откуда
        пришел

        Очень нагружается трафик

    - Случайная

        Полученный пакет рассылается по случайной линии связи, кроме той, откуда
        пришел

        Пакет доходит за неопределенное время

    - По прецедентам

        Строим табличку: `адрес назначения -> адрес линии связи`

        Если записи в табличке нет, то используем один из прошлых подходов

        Если запись есть, то отправляем, куда надо

- Динамическая маршрутизация

    - Векторно-дистанционные

        Хранится таблица маршрутов + расстояние по каждому маршруту

        Время от времени маршрутизаторы переправляют друг другу таблицы, чтобы
        обновлять информацию. Это происходит часто: раз в секунду или чаще

        Дополнительно вводится время жизни записи. Если оно истекло, то запись
        удаляется.

    - Алгоритмы состояния связей

        Каждый маршрутизатор должен:
        + Обнаруживать адреса соседей и узнавать их
        + Задавать вес связи каждого из соседей
        + Создавать пакет с собранной информацией
        + Пересылать пакеты других маршрутизаторов
        + Коллективно решать задачу оптимизации

== Интерфейсы

Модели передачи данных
- Потоковая
- Сообщений

На локальном компьютере проще реализовать потоковую модель, в сети --- модель
сообщений.

Модели передачи данных
- datagramm -- connection-less

    Разные пакеты могут идти по разным маршрутам. Порядок получения пакетов не
    установлен

- connection-oriented

    Все пакеты идут по одному заранее установленному маршруту, приходят в том же
    порядке
