Занесение информации в порт часто только инициализирует операцию, а сама
операция продолжается дольше

*Контроллер устройств* --- устройство, которое определяет, что делать устройству
после получения информации через порт. Контроллер -- это часть устройства

== Архитектура контроллера

Регистры:
- состояния (read only)
    - бит занятости
    - бит готовности данных (для чтения)
    - бит ошибки
- управления (write only)
    - биты кода команды
    - биты режима работы
    - бит готовности команды
- выходных данных (read only)
- входных данных (write only)

== Про прерывания

Polling --- постоянный опрос устройства на предмет его занятости. Неэффективно
т.к. зазря жрет ресурсы процессора

Для избежания polling-а добавляют линию прерываний

При получении прерывания, процессор сохраняет регистры и передает управление ОС,
потом восстанавливаем контекст

Можно сажать несколько устройств на одну линию прерываний, тогда придется
узнавать, какое устройство создало прерывание

Обычно делают целую шину прерываний, присоединяя её к контроллеру прерываний

Устройствам можно задавать приоритеты

Механизм прерывания решили использовать и для других случаев: появились
программные прерывания и исключительные ситуации:
- Внешние Прерывания
    
    - Обнаруживаются между выполнением команд
    - Сохраняется часть контекста перед выполнением следующей команды
    - Не связаны с работой процессора, совершенно непредсказуемы

- Исключительные ситуации

    - Возникают, когда команда не может быть завершена (например, при делении на
      0)
    - Сохраняется часть контекста перед выполнением текущей команды
    - Связаны с работой процессора, но непредсказуемы

- Программные прерывания

    - Возникают в результате выполнения специальной команды
    - Сохраняется часть контекста перед выполнением следующей команды
    - Связаны с работой процессора, предсказуемы

Писать большие данные в IO через процессор неэффективно. Хочется писать
напрямую из оперативной памяти в IO.

Контроллер DMA (Direct Memory Access) --- *единственное* устройство, кроме
процессора, которое может "рулить" оперативной памятью

== Основные различия IO устройств

- Скорость обмена информацией
- Возможность использования несколькими процессами параллельно
- Запоминание выведенной информации для последующего ввода
- Символьные (выводят информацию побайтовой) и блочные (выводят информацию
  большими блоками)
- Read? Write?

Решили, как в биологии, разбить все устройства на классы

Вместе с каждым устройством поставляется специальная работа для работы с данным
устройством -- драйвер.

== Структура системы IO

- Software:
    - Остальная часть ОС
    - Базовая подсистема ввода-вывода
    - Драйвер
- Hardware:
    - Контроллер
    - Устройство

== Систематизация внешних устройств

- Символьные
- Блочные
- Сетевые устройства
- Всё остальное

=== В UNIX-е

Только два первых класса

Символьные устройства:
- `get` --- ввести символ
- `put` --- вывести символ

Блочные устройства:
- `read` --- считать блок
- `write` --- записать символ
- `seek` --- найти блок (для тех устройств, у которых есть random access)

Выполнить произвольную команду --- `ioctl` (Input Output Control) пишет
произвольную информацию в произвольный порт

[Ре]иничиализировать драйвер и устройство --- `open`
Временно завершить работу --- `close`
Опросить состояние устройства --- `poll`

== Функции базовой подсистемы ввода-вывода

Функции:
- трансляция из системных вызовов в функции драйверов
- поддержка блокирующих, неблокирующих и асинхронных вызовов
- буфферизация и кэширования
- spooling и монопольный захват усторйств
- частичная обработка ошибок и прерываний
- планирование последовательности запросов

=== Поддержка блокирующих, неблокирующих и асинхронных вызовов

- Блокирующий: "Исполнение" $->$ "Ожидание", пока операция не выполнится
  полностью
- Неблокирующий: Операция ввода-вывода может быть выполнена не в полном объеме
- Асинхронный: Никогда не блокируется. Операция выполняется полностью. Работает
  в фоновом режиме.

=== Буферизация и кэширование

Буфер --- область памяти для запоминания промежуточной информации при обмене

Зачем буфер?:
- Разные сообщения приема и передачи участников обмена
- Разные объемы данных, которые могут быть приняты или переданы участниками
  обмена
- Необходимо копирование данных из приложения в ядро ОС и обратно

Кэш --- область быстрой памяти, который содержит копию данных из более медленной
памяти

В подсистеме ввода-вывода часто одна область памяти является и буфером, и кэшем

Разница между буфером и кэшем:
- Буфер для согласования параметров, кэш --- только для ускорения
- Кэш всегда содержит только копию, буфер может быть единственным владельцем
  данных

=== Spooling и монопольный захват

Некоторые устройства (например, принтер) не могут быть использованы несколькими
процессами одновременно

- Монопольный захват
- Spooling
    
    Буфер (отдельный для каждого процесса), содержит входные или выходные
    данные для устройства
